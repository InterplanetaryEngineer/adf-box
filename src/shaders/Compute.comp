#version 450

#define groupSize 8
#define subdiv 2
#define valres 2
#define textureWidth 16384

layout (local_size_x = groupSize, local_size_y = groupSize, local_size_z = 1 ) in;

layout(binding = 0) uniform restrict readonly UniformBufferObject
{
    mat4 view;
    vec4 position;
    int buffer_size;
    float FOV;
    float margin;
    float limit;
    vec4 light;
	vec2 screen_size;
    float intensity;
};

layout(binding = 1) restrict readonly buffer octDataBuffer {
	int octData[];
};
layout(binding = 2) uniform sampler2D values;
layout(binding = 3) uniform restrict writeonly image2D dest;

int index = 0;
vec2 dimfactor;

vec3 lower = vec3(0, 0, 0);
float scale = 1;

vec4 sam(vec2 p)
{
    return texture(values, (p + vec2(.5, .5)) * dimfactor);
}

float sample_at(vec3 d, float scale)
{
    int cellindex = index * valres;
    vec2 p = ivec2(cellindex % textureWidth, cellindex / textureWidth * valres);

    vec4 load = sam(d.xy + p);
    vec4 weights = vec4(1 - d.z, d.z, 0, 0);
    float interpolated = dot(load, clamp(weights, 0, 1));
    float result = (interpolated - .25) * scale * 4;
    return result;
}

float interpol_world(vec3 pos)
{
    vec3 d = clamp((pos - lower) / scale, 0, 1) * (valres - 1); //smoothstep(lower, higher, pos);//
    return sample_at(d, scale);
}

vec3 gradient(vec3 pos)
{
    int cellindex = index * valres;
    vec2 p = ivec2(cellindex % textureWidth, cellindex / textureWidth * valres);
    vec2 ph = p + vec2(valres, 0);

    vec3 d = clamp((pos - lower) / scale, 0, 1);
    vec2 xzl = (vec2(d.x, 0) + p);


    vec2 xl = sam(p + vec2(0, d.y)).xy;
    vec2 xh = sam(p + vec2(1, d.y)).xy;
    vec2 dx = mix(vec2(xl.x, xh.x), vec2(xl.y, xh.y), d.z);

    vec2 yl = sam(p + vec2(d.x, 0)).xy;
    vec2 yh = sam(p + vec2(d.x, 1)).xy;
    vec2 dy = mix(vec2(yl.x, yh.x), vec2(yl.y, yh.y), d.z);


    vec2 dz = sam(p + d.xy).xy;

    return vec3(dx.y - dx.x, dy.y - dy.x, dz.y - dz.x);
}

void scale_down(ivec3 p)
{
    scale /= subdiv;
    lower += vec3(p) * scale;
}



void find(vec3 pos)
{
    index = 0;
    lower = vec3(0, 0, 0);
    scale = 1;

    while (index < buffer_size)
    {
        const ivec3 dir = min(ivec3(clamp((pos - lower) / scale, 0, 1) * subdiv), ivec3(subdiv - 1, subdiv - 1, subdiv - 1));
        const int p = dir.x + dir.y * subdiv + dir.z * subdiv * subdiv;
        const int next = octData[index * 8 + p];
        if (next < 0)
            return;
        index = next;
        scale_down(dir);
    }
}

vec3 ray(ivec2 coord, vec2 destsize)
{
	vec2 screendir = vec2(coord) / destsize.y - vec2(destsize.x / destsize.y * .5, .5);
	vec4 dir = view * vec3(screendir * FOV, .5).xyzz;
	return normalize(dir.xyz);
}

void shade(ivec2 pospx, float brightness, vec3 normal) {
    imageStore(dest, pospx, vec4(brightness - normal.y*0.05 + 0.05));
} 

void main()
{
	ivec2 pospx = ivec2(gl_GlobalInvocationID.xy);
	ivec2 destsize = imageSize(dest);
	dimfactor = vec2(1) / textureSize(values, 0);
	if (pospx.x >= destsize.x || pospx.y >= destsize.y) {
    	return;
	}

	float prox = 1;

	vec3 pos = position.xyz;
	vec3 dir = ray(pospx, vec2(destsize));

	for (int i = 0; (prox > margin * 2 || prox < 0) && i < 100; i++) {
		if (dot(pos - vec3(0.5), pos - vec3(0.5)) > limit) {
			imageStore(dest, pospx, vec4(0.005, 0.01, 0.2, 1.0));
			return;
		}
		find(pos);
        prox = interpol_world(pos);
        pos += dir * prox;
    }

    dir = normalize(light.xyz - pos);
    vec3 normal = normalize(gradient(pos));
    pos += dir * margin * 10;
    float angle = dot(dir, normal);
    if (angle < 0) {
        shade(pospx, 0.0, normal);
        return;
    }
    float dist = length(light.xyz - pos) / 2;

    for (int i = 0; (prox > -margin) && i < 40; i++) {
        if (prox > dist || any(lessThan(pos, vec3(0))) || any(greaterThan(pos, vec3(1)))) {
            float attenuation = angle / (dist*dist) *  (exp2(intensity) - 1);
            shade(pospx, attenuation, normal);
            return;
        }
        find(pos);
        prox = interpol_world(pos);
        pos += dir * prox;// * (1 - inf.margin);
    }
    shade(pospx, 0.0, normal);
}