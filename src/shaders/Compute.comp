#version 450

#define groupSize 8
#define subdiv 2
#define vpercell 2
#define textureWidth 16384

layout (local_size_x = groupSize, local_size_y = groupSize, local_size_z = 1 ) in;

layout(binding = 0) uniform restrict readonly UniformBufferObject
{
    mat4 view;
    vec4 position;
    int buffer_size;
    float FOV;
    float margin;
    float limit;
	vec2 screen_size;
};

layout(binding = 1) restrict readonly buffer octDataBuffer {
	int octData[];
};
layout(binding = 2) uniform sampler2D values;
layout(binding = 3) uniform restrict writeonly image2D dest;

int index = 0;
vec2 dimensions;

vec3 lower = vec3(0, 0, 0);
float scale = 1;

vec2 sam(vec2 p)
{
    return texture(values, (p + vec2(.5, .5)) * dimensions).xy;
}

float sample_at(vec3 d, float scale)
{
    int cellindex = index * vpercell;
    vec2 p = ivec2(cellindex % textureWidth, cellindex / textureWidth * vpercell);

    vec2 load = sam(d.xy + p);
    // float loadH = sam(d.xy + p + vec2(vpercell, 0));
    float result = (mix(load.x, load.y, d.z) - .25) * scale * 4;
    return result;
}

float interpol_world(vec3 pos)
{
    vec3 d = clamp((pos - lower) / scale, 0, 1); //smoothstep(lower, higher, pos);//
    return sample_at(d, scale);
}

vec3 gradient(vec3 pos)
{
    vec3 d = clamp((pos - lower) / scale, 0, 1);
    vec2 p = ivec2((index * 2) % textureWidth, index * 2 / textureWidth * 2);
    vec2 ph = p + vec2(vpercell, 0);

    vec2 xzl = (vec2(d.x, 0) + p);


    vec2 xl = sam(p + vec2(0, d.y));
    vec2 xh = sam(p + vec2(1, d.y));
    vec2 dx = mix(vec2(xl.x, xh.x), vec2(xl.y, xh.y), d.z);

    vec2 yl = sam(p + vec2(d.x, 0));
    vec2 yh = sam(p + vec2(d.x, 1));
    vec2 dy = mix(vec2(yl.x, yh.x), vec2(yl.y, yh.y), d.z);


    vec2 dz = sam(p + d.xy);

    return vec3(dx.y - dx.x, dy.y - dy.x, dz.y - dz.x);
}

void scale_down(ivec3 p)
{
    scale /= subdiv;
    lower += vec3(p) * scale;
}



void find(vec3 pos)
{
    index = 0;
    lower = vec3(0, 0, 0);
    scale = 1;

    while (index < buffer_size)
    {
        const ivec3 dir = min(ivec3(clamp((pos - lower) / scale, 0, 1) * subdiv), ivec3(subdiv - 1, subdiv - 1, subdiv - 1));
        const int p = dir.x + dir.y * subdiv + dir.z * subdiv * subdiv;
        const int next = octData[index * 8 + p];
        if (next < 0)
            return;
        index = next;
        scale_down(dir);
    }
}

vec3 ray(ivec2 coord, vec2 destsize)
{
	vec2 screendir = vec2(coord) / destsize.y - vec2(destsize.x / destsize.y * .5, .5);
	vec4 dir = view * vec3(screendir * FOV, .5).xyzz;
	return normalize(dir.xyz);
}

void main()
{
	ivec2 pospx = ivec2(gl_GlobalInvocationID.xy);
	ivec2 destsize = imageSize(dest);
	dimensions = vec2(1) / textureSize(values, 0);
	if (pospx.x >= destsize.x || pospx.y >= destsize.y) {
    	return;
	}

	float prox = 1;

	vec3 pos = position.xyz;
	vec3 dir = ray(pospx, vec2(destsize));

	// imageStore(dest, pospx, vec4(interpol_world(pos), 0, 0, 1));
	// return;

	for (int i = 0; (prox > margin * 2 || prox < 0) && i < 200; i++) {
		if (dot(pos - vec3(0.5), pos - vec3(0.5)) > limit) {
			imageStore(dest, pospx, vec4(0.005, 0.01, 0.2, 1.0));
			return;
		}
		find(pos);
        prox = interpol_world(pos);
        pos += dir * prox;// * (1 - inf.margin);
    }
    float angle = abs(dot(dir, normalize(gradient(pos))));
	imageStore(dest, pospx, vec4(angle, angle, angle, 1.0));
}